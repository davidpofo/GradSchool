<?xml version="1.0" ?>
<PsychoPy2experiment encoding="utf-8" version="1.85.6">
  <Settings>
    <Param name="Monitor" updates="None" val="testMonitor" valType="str"/>
    <Param name="color" updates="None" val="$[0,0,0]" valType="str"/>
    <Param name="colorSpace" updates="None" val="rgb" valType="str"/>
    <Param name="Experiment info" updates="None" val="{'participant':'', 'session':'001'}" valType="code"/>
    <Param name="JS libs" updates="None" val="packaged" valType="str"/>
    <Param name="Units" updates="None" val="use prefs" valType="str"/>
    <Param name="Save excel file" updates="None" val="False" valType="bool"/>
    <Param name="Enable Escape" updates="None" val="True" valType="bool"/>
    <Param name="Save psydat file" updates="None" val="True" valType="bool"/>
    <Param name="Window size (pixels)" updates="None" val="[1024, 768]" valType="code"/>
    <Param name="Full-screen window" updates="None" val="True" valType="bool"/>
    <Param name="blendMode" updates="None" val="avg" valType="str"/>
    <Param name="Use version" updates="None" val="" valType="str"/>
    <Param name="HTML path" updates="None" val="html" valType="str"/>
    <Param name="Save csv file" updates="None" val="False" valType="bool"/>
    <Param name="OSF Project ID" updates="None" val="" valType="str"/>
    <Param name="Save log file" updates="None" val="True" valType="bool"/>
    <Param name="Save wide csv file" updates="None" val="True" valType="bool"/>
    <Param name="Show mouse" updates="None" val="False" valType="bool"/>
    <Param name="Data filename" updates="None" val="'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])" valType="code"/>
    <Param name="Show info dlg" updates="None" val="True" valType="bool"/>
    <Param name="expName" updates="None" val="Shapebuilder_8_8_2016" valType="str"/>
    <Param name="logging level" updates="None" val="exp" valType="code"/>
    <Param name="Screen" updates="None" val="1" valType="num"/>
  </Settings>
  <Routines>
    <Routine name="ShapebuilderFunction">
      <CodeComponent name="function">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="function" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#&amp;#10;&amp;#10;def ShapeBuilderFunction(**OptionalParameters):&amp;#10;&amp;#10;    #&amp;#10;    #####################   MODULES TO IMPORT&amp;#10;    #########################################################################################################&amp;#10;    #########################################################################################################&amp;#10;    #########################################################################################################&amp;#10;    #&amp;#10;    import math&amp;#10;    import numpy as np&amp;#10;    import random&amp;#10;    from psychopy import visual, info, core&amp;#10;    from sys import platform as _platform&amp;#10;    import numbers&amp;#10;&amp;#10;#    jeopardy = sound.SoundPyo(volume = 1)&amp;#10;#    jeopardy.setSound('jeopardy.wav')&amp;#10;#    expInfo = info.RunTimeInfo(refreshTest = None)&amp;#10;#    versionNum = int(str(expInfo['psychopyVersion']).replace('.',''))&amp;#10;&amp;#10;    #&amp;#10;    #####################   Functions&amp;#10;    #########################################################################################################&amp;#10;    #########################################################################################################&amp;#10;    #########################################################################################################&amp;#10;    #&amp;#10;    def EucDist(Pos1,Pos2):&amp;#10;        return math.sqrt(abs(Pos1[0]-Pos2[0])**2 + abs(Pos1[1]-Pos2[1])**2)&amp;#10;&amp;#10;    def shift(seq, n):&amp;#10;        n = n % len(seq)&amp;#10;        return seq[n:] + seq[:n]&amp;#10;&amp;#10;    def DrawStimuliFlip(WhatToDisplay,Window):&amp;#10;        [curImage.draw() for curImage in WhatToDisplay]&amp;#10;        Window.flip()&amp;#10;&amp;#10;    def AngleCalc(Rad,Xorigin,Yorigin,YCorrectionFactor,AngleNum,Start):&amp;#10;        X=Start - float(360)/AngleNum&amp;#10;        Degrees = []&amp;#10;        for i in range(0,AngleNum):&amp;#10;            X = X + float(360)/AngleNum&amp;#10;            Degrees.append(X)&amp;#10;        Degrees=np.array(Degrees)&amp;#10;        Xcoordinates=Xorigin + np.cos(np.deg2rad(Degrees)) * Rad&amp;#10;        Ycoordinates=Yorigin + np.sin(np.deg2rad(Degrees)) * Rad * YCorrectionFactor&amp;#10;        return (zip(Xcoordinates,Ycoordinates))&amp;#10;&amp;#10;    #This is just used because I have had problems with the mouse &amp;#10;    #when switching between macs and windows. The main issue is that&amp;#10;    #event.Mouse() has issues if a window (e.g., event.Mouse(win =myWindow) is not supplied on windows machines&amp;#10;    #however, on macs specifying the window causes problems, but only on older versions &amp;#10;    #of psychopy...what a mess. On a mac, with new versions (&gt;1.82..I think!), you need to specify the window.&amp;#10;    #Thus, this function gets what the version.&amp;#10;    def DetermineSystemType(psychopyVersion):&amp;#10;        if _platform == &quot;linux&quot; or _platform == &quot;linux2&quot;:&amp;#10;            core.quit()&amp;#10;        elif _platform == &quot;darwin&quot;:&amp;#10;            if versionNum &lt;= 18201:&amp;#10;                compType = 'mac'&amp;#10;            else:&amp;#10;                compType = 'pc'&amp;#10;        elif _platform == &quot;win32&quot;:&amp;#10;            compType = 'pc'&amp;#10;        else:&amp;#10;            compType = 'pc'&amp;#10;        return(compType)&amp;#10;&amp;#10;&amp;#10;    ################# Optional Paramaeter Stuff&amp;#10;    #########################################################################################################&amp;#10;    #########################################################################################################&amp;#10;    #########################################################################################################&amp;#10;    #Do you want to write data to the file&amp;#10;    if 'writeData' in OptionalParameters:&amp;#10;        WriteData = OptionalParameters['writeData']&amp;#10;        if WriteData not in [True,False]:&amp;#10;            print('Only True or False are possible parameters for writeData brahh!')&amp;#10;    elif 'writeData' not in OptionalParameters:&amp;#10;        WriteData = True&amp;#10;&amp;#10;    if 'numPracTrials' in OptionalParameters:&amp;#10;        if isinstance(OptionalParameters['numPracTrials'],numbers.Number):&amp;#10;            if OptionalParameters['numPracTrials'] &lt; 27 and OptionalParameters['numPracTrials'] &gt; -1:&amp;#10;                numPracticeTrials = int(OptionalParameters['numPracTrials'])&amp;#10;            elif OptionalParameters['numPracTrials'] &lt; 0 or OptionalParameters['numPracTrials'] &gt; 26:&amp;#10;                print('Please enter a non-negative integer for the number of practice trials that is less than 26.')&amp;#10;                core.quit()&amp;#10;        else:&amp;#10;            print('Please enter a single number for &quot;numPracTrials&quot;.')&amp;#10;            core.quit()&amp;#10;    elif 'numPracTrials' not in OptionalParameters:&amp;#10;        numPracticeTrials = 6&amp;#10;&amp;#10;&amp;#10;    if 'win' in OptionalParameters:&amp;#10;        window = OptionalParameters['win']&amp;#10;    elif 'win' not in OptionalParameters:&amp;#10;        window = visual.Window(fullscr=True,monitor='Default',units='norm',colorSpace='rgb')&amp;#10;&amp;#10;    #Had to include this because I was having trouble &amp;#10;    #automatically detecting the version type on windows machines.&amp;#10;    if 'computerAndVersionType' in OptionalParameters:&amp;#10;        if OptionalParameters['computerAndVersionType'] == 'pc':&amp;#10;            myMouse = event.Mouse(win=window)&amp;#10;        elif OptionalParameters['computerAndVersionType'] == 'mac':&amp;#10;            myMouse = event.Mouse(win=window)&amp;#10;        elif OptionalParameters['computerAndVersionType'] == 'macOld':&amp;#10;            myMouse = event.Mouse()&amp;#10;        else:&amp;#10;            print('Not a valid option for &quot;computerAndVersionType&quot; -- &quot;pc&quot;, &quot;mac&quot;, or &quot;macOld&quot; d00d.')&amp;#10;            core.quit()&amp;#10;    elif 'computerAndVersionType' not in OptionalParameters:&amp;#10;        myMouse = event.Mouse(win=window)&amp;#10;&amp;#10;    if 'physicalMonSize' in OptionalParameters:&amp;#10;        screenRez = win.size&amp;#10;        physicalMonSize = OptionalParameters['physicalMonSize']&amp;#10;        yCorrFactor = float(physicalMonSize[0])/physicalMonSize[1]&amp;#10;    elif 'physicalMonSize' not in OptionalParameters:&amp;#10;        yCorrFactor = 1.6&amp;#10;&amp;#10;&amp;#10;    background = visual.Rect(window, size=(window.size)*2, fillColor=(-1.0,-1.0,-1.0))&amp;#10;    #Enter monitor size in cm. If left at [0,0] it is assumed that&amp;#10;    #1 pixel on the x axis is the same size as 1 pixel on the y axis&amp;#10;    monSize=[0,0]&amp;#10;&amp;#10;    shapeLWidth=3&amp;#10;    lineCol=[-1,-1,-1]&amp;#10;&amp;#10;    trialNum = 0 &amp;#10;    curMemSize=2&amp;#10;    startShapeDur=0.7&amp;#10;    curScore = 0&amp;#10;    curMemTrial = 0&amp;#10;    timeBetweenShapes = 0.5&amp;#10;    &amp;#10;    if numPracticeTrials == 0:&amp;#10;        numTimesThroughSB = 1&amp;#10;    else:&amp;#10;        numTimesThroughSB = 2&amp;#10;&amp;#10;    timesThrough = 0&amp;#10;    whenToChange = [3,6,9]&amp;#10;&amp;#10;    difColors=[&amp;#10;    [ 1, 1,-1],&amp;#10;    [-1,-1, 1],&amp;#10;    [ 1,-1,-1],&amp;#10;    [-1, 1,-1]&amp;#10;    ]&amp;#10;&amp;#10;#    edges=[[-0.32,0.32],[0.32,0.32],[0.32,-0.32],[-0.32,-0.32]]&amp;#10;    edges=[[-0.25,0.25],[0.25,0.25],[0.25,-0.25],[-0.25,-0.25]]&amp;#10;    edges=[[curEdge[0],curEdge[1]*yCorrFactor] for curEdge in edges]&amp;#10;&amp;#10;    Ydist=float(max(edges[0][0],edges[2][0]) - min(edges[0][0],edges[2][0]))/5*yCorrFactor&amp;#10;    Xdist=float(max(edges[1][0],edges[3][0]) - min(edges[1][0],edges[3][0]))/5&amp;#10;&amp;#10;    outerRect=visual.Rect(window,lineWidth=0,lineColor=(-0.6,-0.6,-0.6),fillColor=(0,0,0),width=abs(edges[0][0])*5,height=abs(edges[0][0])*4*yCorrFactor,pos=(0,0))&amp;#10;    outerRectShapeColor = visual.Rect(window,lineWidth=0,fillColor=[-0.2,-0.2,-0.2],width=abs(edges[0][0])*5*1.01,height=abs(edges[0][0])*4*yCorrFactor*1.01,pos=outerRect.pos,opacity=0.4)&amp;#10;    defRectColor = outerRectShapeColor.fillColor&amp;#10;&amp;#10;    triangleDistX=0.052&amp;#10;    triangleDistY=triangleDistX * yCorrFactor&amp;#10;&amp;#10;    realTriDistX = triangleDistX * 0.8&amp;#10;    realTriDistY = triangleDistY * 1.45&amp;#10;    triangleYAdj = 2.9&amp;#10;&amp;#10;    if yCorrFactor &gt; 1.3:&amp;#10;        textSizeInc = 0.65&amp;#10;        realTriDistX = triangleDistX * 0.8&amp;#10;        realTriDistY = triangleDistY * 1.45&amp;#10;        triangleYAdj = 2.9&amp;#10;    else:&amp;#10;        textSizeInc = 0.45&amp;#10;        realTriDistX = triangleDistX * 0.8&amp;#10;        realTriDistY = triangleDistY * 1.65&amp;#10;        triangleYAdj = 2.5&amp;#10;&amp;#10;&amp;#10;    pushOut = 1.05&amp;#10;&amp;#10;    allPos = []&amp;#10;    cenPos = []&amp;#10;    for i in range(0,len(edges)):&amp;#10;        curPos=[]&amp;#10;        if i == 0 or i== 2:&amp;#10;            curEdgeDist = float(max(edges[i][0],edges[i+1][0]) - min(edges[i][0],edges[i+1][0]))/5&amp;#10;            float(max(edges[i][0],edges[i+1][0]) - min(edges[i][0],edges[i+1][0]))/2&amp;#10;            if i == 0:&amp;#10;                for j in range(1,5):&amp;#10;                    curPos.append([edges[i][0] + curEdgeDist*j,edges[i][1]])&amp;#10;            else:&amp;#10;                for j in range(1,5):&amp;#10;                    curPos.append([edges[i][0] - curEdgeDist*j,edges[i][1]])&amp;#10;                curPos=curPos[::-1]&amp;#10;        elif i == 1:&amp;#10;            curEdgeDist = float(max(edges[i][1],edges[i+1][1]) - min(edges[i][1],edges[i+1][1]))/5&amp;#10;            for j in range(1,5):&amp;#10;                curPos.append([edges[i][0], edges[i][1] - curEdgeDist*j])&amp;#10;        else:&amp;#10;            curEdgeDist = float(max(edges[3][1],edges[0][1]) - min(edges[3][1],edges[0][1]))/5&amp;#10;            for j in range(1,5):&amp;#10;                curPos.append([edges[i][0], edges[i][1] + curEdgeDist*j])&amp;#10;            curPos=curPos[::-1]&amp;#10;        allPos.append(curPos)&amp;#10;    for i in range(len(allPos)):&amp;#10;        for j in range(len(allPos[i])):&amp;#10;            for k in range(1):&amp;#10;                if i == 0 or i == 2:&amp;#10;                    allPos[i][j][1] = float(allPos[i][j][1]) * pushOut&amp;#10;                else:&amp;#10;                    allPos[i][j][0] = float(allPos[i][j][0]) * pushOut&amp;#10;&amp;#10;&amp;#10;    squareOutlinePos=[]&amp;#10;&amp;#10;    allSquarePos=[]&amp;#10;    allXSqPos=[]&amp;#10;    allYSqPos=[]&amp;#10;    yTempStart = edges[0][0]&amp;#10;    for i in range(1,5):&amp;#10;        allXSqPos.append(edges[0][0]+Xdist*i)&amp;#10;        allYSqPos.append(-edges[0][1]+Ydist*i)&amp;#10;&amp;#10;    for i in range(0,len(allYSqPos)):&amp;#10;        for j in range(0,len(allXSqPos)):&amp;#10;            allSquarePos.append([allXSqPos[j],allYSqPos[i]])&amp;#10;&amp;#10;    allSquareRect=[]&amp;#10;    for i in range(0,len(allSquarePos)):&amp;#10;        allSquareRect.append(visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0.4,0.4,0.4),width=Xdist,height=Ydist,pos=allSquarePos[i]))&amp;#10;&amp;#10;&amp;#10;    scoreRect=visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0.45,0.45,0.45),width=Xdist*2.5,height=Ydist*0.8,pos=(0,edges[0][1]*1.5))&amp;#10;&amp;#10;    scoreNum=visual.TextStim(window, text=curScore,color = (-1,0.2,0.2),pos=scoreRect.pos,height=Ydist*0.7)&amp;#10;    scoreLabel=visual.TextStim(window, text=&quot;Score&quot;,color = 'black',pos=(scoreRect.pos[0],scoreRect.pos[1]+Ydist*0.8),height=Ydist*0.5)&amp;#10;&amp;#10;    scoreValueTexts=[visual.TextStim(window, text=0,color = (-1,-1,-1),pos=scoreRect.pos,height=Ydist*0.6) for i in range(0,4)]&amp;#10;&amp;#10;    beginRect=visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0,0.3,0.8),width=Xdist*2,height=Ydist*0.8,pos=(0.2,edges[0][1]*-1.5))&amp;#10;    beginText=visual.TextStim(window, text=&quot;Begin&quot;,color = (-1,-1,-1),pos=beginRect.pos,height=Ydist*0.5)&amp;#10;&amp;#10;    practiceRect=visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0,0.3,0.8),width=Xdist*2,height=Ydist*0.8,pos=(-beginRect.pos[0],edges[0][1]*-1.5))&amp;#10;    practiceText=visual.TextStim(window, text=&quot;Practice&quot;,color = (-1,-1,-1),pos=practiceRect.pos,height=beginText.height)&amp;#10;&amp;#10;    rectangles=[]&amp;#10;    testRect=[]&amp;#10;    unRect=[]&amp;#10;    for i in range(0,len(edges)):&amp;#10;        curPos=allPos[i][0]&amp;#10;        rectangles.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],width=triangleDistX*1.4,height=triangleDistY*1.4,pos=curPos))&amp;#10;        testRect.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],width=triangleDistX*1.4,height=triangleDistY*1.4,pos=curPos))&amp;#10;        unRect.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],width=triangleDistX*1.4,height=triangleDistY*1.4,pos=curPos))&amp;#10;&amp;#10;    circles=[]&amp;#10;    testCircles=[]&amp;#10;    unCircles=[]&amp;#10;    for i in range(0,len(edges)):&amp;#10;        curPos=allPos[i][1]&amp;#10;        curVertices = AngleCalc(float(triangleDistX)/2*1.5,0,0,yCorrFactor,90,-90)&amp;#10;        circles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&amp;#10;        testCircles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&amp;#10;        unCircles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&amp;#10;&amp;#10;&amp;#10;&amp;#10;&amp;#10;    triangles=[]&amp;#10;    testTriangles=[]&amp;#10;    unTriangles=[]&amp;#10;    for i in range(0,len(edges)):&amp;#10;        curPos=allPos[i][2]&amp;#10;        triangles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i], \&amp;#10;                        vertices=((-realTriDistX,-float(realTriDistX)/2*triangleYAdj),(0,float(realTriDistY)/2),(realTriDistX,-float(realTriDistX)/2*triangleYAdj)), closeShape=True, pos=curPos))&amp;#10;        testTriangles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i], \&amp;#10;                        vertices=((-realTriDistX,-float(realTriDistX)/2*triangleYAdj),(0,float(realTriDistY)/2),(realTriDistX,-float(realTriDistX)/2*triangleYAdj)), closeShape=True, pos=curPos))&amp;#10;        unTriangles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i], \&amp;#10;                        vertices=((-realTriDistX,-float(realTriDistX)/2*triangleYAdj),(0,float(realTriDistY)/2),(realTriDistX,-float(realTriDistX)/2*triangleYAdj)), closeShape=True, pos=curPos))&amp;#10;&amp;#10;&amp;#10;    diamonds=[]&amp;#10;    testDiamonds=[]&amp;#10;    unDiamonds=[]&amp;#10;    diamondCorrX = 1.15&amp;#10;    diamondCorrY = 1.6&amp;#10;    for i in range(0,len(edges)):&amp;#10;        curPos=allPos[i][3]&amp;#10;        curVertices = [[0,float(triangleDistY)*diamondCorrY/2],[float(triangleDistX)*diamondCorrX/2,0],[0,-(float(triangleDistY)*diamondCorrY/2)],[-(float(triangleDistX)*diamondCorrX/2),0]]&amp;#10;        diamonds.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&amp;#10;        testDiamonds.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&amp;#10;        unDiamonds.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&amp;#10;&amp;#10;    instRect = visual.Rect(window,lineWidth=shapeLWidth,lineColor='black',fillColor=(0,0,0),width=Xdist*4,height=Ydist*4,pos=(0,0),opacity=0.9)&amp;#10;&amp;#10;    borderingRects = []&amp;#10;    borderingRects2 = []&amp;#10;    for i in range(0,len(edges)):&amp;#10;        if i == 0 or i ==2:&amp;#10;            curPos=[edges[i][0]*pushOut,0]&amp;#10;            curXSize = Xdist&amp;#10;            curYSize = Ydist*4&amp;#10;        else:&amp;#10;            curPos=[0,edges[i][1]*pushOut]&amp;#10;            curXSize = Xdist*4&amp;#10;            curYSize = Ydist&amp;#10;            &amp;#10;        borderingRects.append(visual.Rect(window,lineWidth=0,lineColor='black',fillColor=(0,0,0),width=curXSize,height=curYSize,pos=curPos,opacity=0.6))&amp;#10;        borderingRects2.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor='black',fillColor=(0.4,0.4,0.4),width=curXSize,height=curYSize,pos=curPos))&amp;#10;&amp;#10;&amp;#10;&amp;#10;&amp;#10;    allShapes=[]&amp;#10;    testShapes=[]&amp;#10;    unShapes=[]&amp;#10;    for i in range(0,4):&amp;#10;        allShapes.append(rectangles[i])&amp;#10;        allShapes.append(circles[i])&amp;#10;        allShapes.append(triangles[i])&amp;#10;        allShapes.append(diamonds[i])&amp;#10;        testShapes.append(testRect[i])&amp;#10;        testShapes.append(testCircles[i])&amp;#10;        testShapes.append(testTriangles[i])&amp;#10;        testShapes.append(testDiamonds[i])&amp;#10;        unShapes.append(unRect[i])&amp;#10;        unShapes.append(unCircles[i])&amp;#10;        unShapes.append(unTriangles[i])&amp;#10;        unShapes.append(unDiamonds[i])&amp;#10;&amp;#10;&amp;#10;    allPosFlat=np.array(allPos)&amp;#10;    allPosFlat=np.reshape(allPosFlat,(allPosFlat.shape[0]*allPosFlat.shape[1],allPosFlat.shape[2]))&amp;#10;    allPosFlat=allPosFlat.tolist()&amp;#10;&amp;#10;    allStimNoPres = []&amp;#10;    allStimNoPres.extend([outerRectShapeColor,outerRect,scoreRect,scoreLabel,scoreNum])&amp;#10;    for i in range(len(allSquareRect)):&amp;#10;        allStimNoPres.append(allSquareRect[i])&amp;#10;    [allStimNoPres.append(borderingRects2[i]) for i in range(len(borderingRects2))]&amp;#10;    for i in range(len(allShapes)):&amp;#10;        allStimNoPres.append(allShapes[i])&amp;#10;&amp;#10;&amp;#10;    ####################### Outer loop starts here&amp;#10;    for outerLoop in range(numTimesThroughSB):&amp;#10;&amp;#10;        curScore = 0&amp;#10;&amp;#10;        instructions='This task tests your ability to remember the ' +\&amp;#10;        'order and spatial position in which a series of colored geometric ' +\&amp;#10;        'shapes are presented. You will see between 2 and 4 shapes. Your job ' +\&amp;#10;        'is to remember the order, spatial position, color, and shape of each ' +\&amp;#10;        'item presented. After the final shape is presented, recreate the ' +\&amp;#10;        'sequence by clicking on the correct colored shape and dragging ' +\&amp;#10;        'it to the appropriate spatial position. The better you do the ' +\&amp;#10;        'more points you will earn. The number of points you earn will ' +\&amp;#10;        'increase the more you get correct without making a mistake. ' +\&amp;#10;        'Click begin to start.'&amp;#10;&amp;#10;        instStim = visual.TextStim(window, text=instructions,color = (-1,-1,-1),pos=(0,0),height=triangleDistX*textSizeInc,wrapWidth = instRect.width * 0.93)&amp;#10;        outerRect.setOpacity(0.6)&amp;#10;        &amp;#10;        &amp;#10;#        compType = DetermineSystemType(versionNum)&amp;#10;#        if compType == 'pc':&amp;#10;#            myMouse = event.Mouse(win=window)&amp;#10;#        elif compType == 'mac':&amp;#10;#            myMouse = event.Mouse()&amp;#10;&amp;#10;&amp;#10;        background.draw()&amp;#10;        [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;        outerRect.draw()&amp;#10;        instRect.draw()&amp;#10;        instStim.draw()&amp;#10;        if timesThrough == 0:&amp;#10;            if numPracticeTrials &gt; 0:&amp;#10;                practiceRect.draw()&amp;#10;                practiceText.draw()&amp;#10;            else:&amp;#10;                beginRect.draw()&amp;#10;                beginText.draw()&amp;#10;        else:&amp;#10;            beginRect.draw()&amp;#10;            beginText.draw()&amp;#10;&amp;#10;&amp;#10;        window.flip()&amp;#10;&amp;#10;        somethingPressed = False&amp;#10;        while not somethingPressed:&amp;#10;            for key in event.getKeys():&amp;#10;                if key in ['escape']:&amp;#10;                    core.quit()&amp;#10;            if myMouse.isPressedIn(beginRect) and timesThrough == 0:&amp;#10;                numTimesThroughSB = 1&amp;#10;                trialNums = [26,26]&amp;#10;                trialTypes = [&quot;ExperimentalTrials&quot;,&quot;ExperimentalTrials&quot;]&amp;#10;                somethingPressed = True&amp;#10;            elif myMouse.isPressedIn(practiceRect):&amp;#10;                numTimesThroughSB = 2&amp;#10;                trialNums = [numPracticeTrials,26]&amp;#10;                trialTypes = [&quot;Practice&quot;,&quot;ExperimentalTrials&quot;]&amp;#10;                somethingPressed = True&amp;#10;            elif myMouse.isPressedIn(beginRect) and timesThrough == 1:&amp;#10;                somethingPressed = True&amp;#10;                trialTypes = [&quot;Practice&quot;,&quot;ExperimentalTrials&quot;]&amp;#10;&amp;#10;&amp;#10;        trialNum = 0 &amp;#10;        curMemSize=2&amp;#10;        startShapeDur=0.7&amp;#10;        curMemTrial = 0&amp;#10;        timeBetweenShapes = 0.5&amp;#10;        totalHighScore = 0&amp;#10;&amp;#10;        scoreNum.setText(curScore)&amp;#10;&amp;#10;        timeBetweenShapes = 1.0&amp;#10;        startShapeDur = 0.8&amp;#10;&amp;#10;        &amp;#10;&amp;#10;        trialType = trialTypes[timesThrough]&amp;#10;        numTrials = trialNums[timesThrough]&amp;#10;        outerRect.setOpacity(1.0)&amp;#10;        shiftNums = [0,4,8,12]&amp;#10;        timeShifts = [0.25]*3 + [0.5]&amp;#10;&amp;#10;&amp;#10;#        jeopardy.play()&amp;#10;        for k in range(len(timeShifts)):&amp;#10;            for i in range(len(shiftNums)):&amp;#10;                colorsDummy = shift(allPosFlat,shiftNums[i])&amp;#10;                [allShapes[j].setPos(colorsDummy[j]) for j in range(len(allShapes))]&amp;#10;                background.draw()&amp;#10;                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                window.flip()&amp;#10;                countDown1 = core.CountdownTimer(timeShifts[k])&amp;#10;                while countDown1.getTime() &gt; 0:&amp;#10;                    doNothing = 1&amp;#10;&amp;#10;&amp;#10;        [allShapes[j].setPos(allPosFlat[j]) for j in range(len(allShapes))]&amp;#10;        background.draw()&amp;#10;        [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;        window.flip()&amp;#10;&amp;#10;&amp;#10;        timesThrough += 1&amp;#10;&amp;#10;        #####################################Outer loop ends here&amp;#10;        for shapeBuilderInnerLoop in range(numTrials):&amp;#10;            myMouse.setVisible(False)&amp;#10;&amp;#10;            ranNumStim=[i for i in xrange(0,len(testShapes))]&amp;#10;            random.shuffle(ranNumStim)&amp;#10;&amp;#10;            ranNumPos=[i for i in xrange(0,len(allSquarePos))]&amp;#10;            random.shuffle(ranNumPos)&amp;#10;&amp;#10;            allSameColor=np.array([[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15]])&amp;#10;            allSameShape=np.transpose(allSameColor)&amp;#10;&amp;#10;            allShapeTestPos=[i for i in range(len(allSquarePos))]&amp;#10;            allShapeTestRandom=[i for i in range(len(allSquarePos))]&amp;#10;            random.shuffle(allShapeTestRandom)&amp;#10;&amp;#10;            normList = [i for i in range(len(allSameColor))]&amp;#10;            colorShuffle = [i for i in range(len(allSameColor))]&amp;#10;            shapeShuffle = [i for i in range(len(allSameColor))]&amp;#10;            random.shuffle(colorShuffle)&amp;#10;            random.shuffle(shapeShuffle)&amp;#10;&amp;#10;            whatType = random.randint(0,2)&amp;#10;&amp;#10;            correctShapesList=[]&amp;#10;            correctShapes=[]&amp;#10;            correctAtt=[]&amp;#10;            cTrialShapes=[]&amp;#10;            positions=[]&amp;#10;            AA=0&amp;#10;            BB=0&amp;#10;&amp;#10;            oneStep = [9,10,11,18,19,20,21,22,23]&amp;#10;            allDiff = [3,4,5,12,13,14,24,25]&amp;#10;&amp;#10;            if curMemSize == 4 and trialNum in [18,19,20]:&amp;#10;                changeIt = [0,2]&amp;#10;                random.shuffle(changeIt)&amp;#10;                changeIt = changeIt[0]&amp;#10;            else:&amp;#10;                changeIt = random.randint(0,curMemSize-2)&amp;#10;&amp;#10;            allObjects = []&amp;#10;            allPositions = []&amp;#10;            for i in range(0,curMemSize):&amp;#10;                curColor = normList[colorShuffle[AA]]&amp;#10;                curShape = normList[shapeShuffle[BB]]&amp;#10;                if whatType == 0:&amp;#10;                    if (trialNum in allDiff):&amp;#10;                        AA += 1&amp;#10;                        BB += 1&amp;#10;                    elif (trialNum in oneStep) and (i==changeIt):&amp;#10;                        AA += 1&amp;#10;                        BB += 1&amp;#10;                    else: &amp;#10;                        AA += 0&amp;#10;                        BB += 1&amp;#10;                else:&amp;#10;                    if (trialNum in allDiff):&amp;#10;                        AA += 1&amp;#10;                        BB += 1&amp;#10;                    elif (trialNum in oneStep) and (i==changeIt):&amp;#10;                        AA += 1&amp;#10;                        BB += 1&amp;#10;                    else: &amp;#10;                        AA += 1&amp;#10;                        BB += 0&amp;#10;                curObject = allSameColor[curColor][curShape]&amp;#10;                allObjects.append(curObject)&amp;#10;                newShape=testShapes[curObject]&amp;#10;                newShape.setPos(allSquarePos[allShapeTestPos[allShapeTestRandom[i]]])&amp;#10;                cTrialShapes.append(newShape)&amp;#10;                correctShapes.append([curObject,allShapeTestPos[allShapeTestRandom[i]]])&amp;#10;                allPositions.append(allShapeTestRandom[i])&amp;#10;                correctAtt.append([allSameColor[curColor].tolist(),allSameShape[curShape].tolist()])&amp;#10;&amp;#10;            core.wait(1.0)&amp;#10;            for i in xrange(0,len(cTrialShapes)):&amp;#10;                background.draw()&amp;#10;                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                [borderingRects[j].draw() for j in range(len(borderingRects))]&amp;#10;                window.flip()&amp;#10;                core.wait(timeBetweenShapes)&amp;#10;                background.draw()&amp;#10;                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                [borderingRects[j].draw() for j in range(len(borderingRects))]&amp;#10;                cTrialShapes[i].draw()&amp;#10;                window.flip()&amp;#10;                core.wait(startShapeDur)&amp;#10;&amp;#10;            background.draw()&amp;#10;&amp;#10;            [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;            window.flip()&amp;#10;&amp;#10;&amp;#10;            grabbedShape = -1&amp;#10;#            myMouse.setVisible(visible=True)&amp;#10;&amp;#10;            selectedShapesNum = []&amp;#10;            timer = [core.CountdownTimer(400.0) for i in range(curMemSize)]&amp;#10;            perfect = 0&amp;#10;            limboShapes = []&amp;#10;            limbShapesTime = [0,0,0,0]&amp;#10;            coloredRectsBin = [0,0,0,0]&amp;#10;            allScores=[]&amp;#10;            placedShapes=[]&amp;#10;            coloredRects=[]&amp;#10;            lightSquare = 0&amp;#10;            #Mouse start&amp;#10;            myMouse.setVisible(True)&amp;#10;            while len(selectedShapesNum) &lt; curMemSize: #continue until keypress&amp;#10;                if sum(limbShapesTime) &gt; 0:&amp;#10;                    outerRectShapeColor.fillColor = defRectColor&amp;#10;                    for j in range(len(limboShapes)):&amp;#10;                        if timer[j].getTime() &lt;= 0:&amp;#10;                            limbShapesTime[j] = 0&amp;#10;                    lightSquare = 0&amp;#10;                    background.draw()&amp;#10;                    coloredRects=[]&amp;#10;                    [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&amp;#10;                    [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                    [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                    [allShapes[k].draw() for k in range(len(allShapes))]&amp;#10;                    [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                    window.flip()&amp;#10;                for key in event.getKeys():&amp;#10;                    if key in ['escape']:&amp;#10;                        core.quit()&amp;#10;                for i in range(0,len(allShapes)):&amp;#10;                    if myMouse.isPressedIn(allShapes[i]) == True:&amp;#10;                        grabbedShape = i&amp;#10;                        allShapes[i].setPos(myMouse.getPos())&amp;#10;                        mouse1, mouse2, mouse3 = myMouse.getPressed()&amp;#10;                        clickedOn = True&amp;#10;                        if grabbedShape &lt;= 3 and grabbedShape &gt; -1:&amp;#10;                            curRectCol = 0&amp;#10;                        elif grabbedShape &lt;= 7 and grabbedShape &gt; 3:&amp;#10;                            curRectCol = 1&amp;#10;                        elif grabbedShape &lt;= 11 and grabbedShape &gt; 7:&amp;#10;                            curRectCol = 2&amp;#10;                        elif grabbedShape &lt;= 15 and grabbedShape &gt; 11:&amp;#10;                            curRectCol = 3&amp;#10;                        outerRectShapeColor.fillColor = difColors[curRectCol]&amp;#10;                        while (clickedOn):&amp;#10;                            allShapes[grabbedShape].setPos(myMouse.getPos())&amp;#10;                            for j in range(len(allSquarePos)):&amp;#10;                                if EucDist([allShapes[grabbedShape].pos[0],allShapes[grabbedShape].pos[1]],allSquarePos[allShapeTestPos[allShapeTestRandom[j]]]) &lt;= 0.06:&amp;#10;                                    coloredRects = []&amp;#10;                                    coloredRectsBin[len(selectedShapesNum)] = 1&amp;#10;                                    lightSquare = 1&amp;#10;                                    coloredRects.append(visual.Rect(window,lineWidth=shapeLWidth*3,lineColor=difColors[curRectCol],fillColor=(0.4,0.4,0.4),width=Xdist,height=Ydist,pos=allSquarePos[allShapeTestPos[allShapeTestRandom[j]]],opacity=0.5))&amp;#10;                            background.draw()&amp;#10;                            [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                            if lightSquare == 1:&amp;#10;                                [coloredRects[k].draw() for k in range(len(coloredRects))]&amp;#10;                            [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                            [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                            [allShapes[k].draw() for k in range(len(allShapes))]&amp;#10;                            window.flip()&amp;#10;                            mouse1, mouse2, mouse3 = myMouse.getPressed()&amp;#10;                            if not mouse1:&amp;#10;                                for j in xrange(0,len(allSquarePos)):&amp;#10;                                    if EucDist([allShapes[grabbedShape].pos[0],allShapes[grabbedShape].pos[1]],allSquarePos[allShapeTestPos[allShapeTestRandom[j]]]) &lt;= 0.06:&amp;#10;                                        placedShapes.append(grabbedShape)&amp;#10;                                        squareSel = allShapeTestPos[allShapeTestRandom[j]]&amp;#10;                                        selectedShapesNum.append(squareSel)&amp;#10;                                        if lightSquare == 1:&amp;#10;                                            [coloredRects[k].draw() for k in range(len(coloredRects))]&amp;#10;                                        unShapes[grabbedShape].setPos(allSquarePos[squareSel])&amp;#10;                                        unShapes[grabbedShape].draw()&amp;#10;                                        ShapeSet = True&amp;#10;                                        curShapeVal = 0&amp;#10;                                        if squareSel == correctShapes[len(selectedShapesNum)-1][1]:&amp;#10;                                            if grabbedShape == correctShapes[len(selectedShapesNum)-1][0]:&amp;#10;                                                if len(selectedShapesNum)-1 == 0 or perfect == 0:&amp;#10;                                                    curShapeVal = 15&amp;#10;                                                else:&amp;#10;                                                    curShapeVal = int(scoreValueTexts[len(selectedShapesNum)-2].text) * 2&amp;#10;                                                perfect = 1&amp;#10;                                            elif grabbedShape in correctAtt[len(selectedShapesNum)-1][1]:&amp;#10;                                                curShapeVal = 10&amp;#10;                                                perfect = 0&amp;#10;                                            elif squareSel == correctShapes[len(selectedShapesNum)-1][1]:&amp;#10;                                                curShapeVal = 5&amp;#10;                                                perfect = 0&amp;#10;                                            else :&amp;#10;                                                curShapeVal = 0&amp;#10;                                                perfect = 0&amp;#10;                                        curScore += curShapeVal&amp;#10;#                                        scoreNum.setText(curScore)&amp;#10;                                        allScores.append(curShapeVal)&amp;#10;                                        [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&amp;#10;                                        scoreValueTexts[len(selectedShapesNum)-1].setText(curShapeVal)&amp;#10;                                        scoreValueTexts[len(selectedShapesNum)-1].setPos(allSquarePos[squareSel])&amp;#10;                                        timer[len(selectedShapesNum)-1] = core.CountdownTimer(1.5)&amp;#10;                                        unShapes[grabbedShape].setPos(allSquarePos[squareSel])&amp;#10;                                        limboShapes.append(unShapes[grabbedShape])&amp;#10;                                        limbShapesTime[len(selectedShapesNum)-1] = 1&amp;#10;                                        clickedOn = False&amp;#10;                                background.draw()&amp;#10;                                [allStimNoPres[k].draw() for k in range(len(allStimNoPres))]&amp;#10;                                if lightSquare == 1:&amp;#10;                                    [coloredRects[k].draw() for k in range(len(coloredRects))]&amp;#10;                                [limboShapes[k].draw() for  k in range(len(limboShapes)) if limbShapesTime[k] == 1]&amp;#10;                                [scoreValueTexts[k].draw() for  k in range(len(limboShapes)) if limbShapesTime[k] == 1]&amp;#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&amp;#10;                                clickedOn = False&amp;#10;                            if sum(limbShapesTime) &gt; 0:&amp;#10;                                for j in range(len(limboShapes)):&amp;#10;                                    if timer[j].getTime() &lt;= 0:&amp;#10;                                        limbShapesTime[j] = 0&amp;#10;                                background.draw()&amp;#10;                                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                                if lightSquare == 1:&amp;#10;                                    [coloredRects[k].draw() for k in range(len(coloredRects))]&amp;#10;                                [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                                [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&amp;#10;                                window.flip()&amp;#10;                        if clickedOn == False:&amp;#10;                            outerRectShapeColor.fillColor = defRectColor&amp;#10;                            lightSquare = 0&amp;#10;                            if sum(limbShapesTime) &gt; 0:&amp;#10;                                for j in range(len(limboShapes)):&amp;#10;                                    if timer[j].getTime() &lt;= 0:&amp;#10;                                        limbShapesTime[j] = 0&amp;#10;                                lightSquare = 0&amp;#10;                                background.draw()&amp;#10;                                coloredRects=[]&amp;#10;                                [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&amp;#10;                                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                                [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                                [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&amp;#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&amp;#10;                                window.flip()&amp;#10;                            else:&amp;#10;                                background.draw()&amp;#10;                                [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&amp;#10;                                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&amp;#10;                                window.flip()&amp;#10;                event.clearEvents()#get rid of other, unprocessed events&amp;#10;&amp;#10;            countDown3 = core.CountdownTimer(0.5)&amp;#10;            while countDown3.getTime() &gt; 0:&amp;#10;                doNothing = 1&amp;#10;&amp;#10;            if (curScore - int(scoreNum.text)) &lt;= 0:&amp;#10;                scoreTime = 0.1&amp;#10;            else:&amp;#10;                scoreTime = (0.75/(curScore - int(scoreNum.text)))*0.25&amp;#10;            countDown1 = core.CountdownTimer(1.5)&amp;#10;            countDown2 = core.CountdownTimer(0)&amp;#10;            if curScore - int(scoreNum.text) &lt; 45:&amp;#10;                curInc = 1&amp;#10;            elif curScore - int(scoreNum.text) &lt; 100:&amp;#10;                curInc = 5&amp;#10;            else:&amp;#10;                curInc = 10&amp;#10;            while countDown1.getTime() &gt; 0:&amp;#10;                countDown2.add(scoreTime)&amp;#10;                if (curScore - int(scoreNum.text)) &lt; 11:&amp;#10;                    curInc = 1&amp;#10;                if int(scoreNum.text) &lt; curScore:&amp;#10;                    scoreNum.setText(int(scoreNum.text) + curInc)&amp;#10;                else:&amp;#10;                    scoreNum.setText(curScore)&amp;#10;                DrawStimuliFlip([background] + allShapes + allStimNoPres + allShapes,window)&amp;#10;                while countDown2.getTime() &gt; 0:&amp;#10;                    doNothing = 1&amp;#10;            scoreNum.setText(curScore)&amp;#10;&amp;#10;            background.draw()&amp;#10;            [allShapes[i].setPos(allPosFlat[i]) for i in range(len(allShapes))]&amp;#10;            [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&amp;#10;&amp;#10;            window.flip()&amp;#10;&amp;#10;&amp;#10;            posHighSchores = [15,30,60,120]&amp;#10;            maxScoreTrial = sum(posHighSchores[0:curMemSize])&amp;#10;            totalHighScore += maxScoreTrial&amp;#10;            &amp;#10;            if WriteData:&amp;#10;                thisExp.addData(&quot;Trial&quot;, trialNum)&amp;#10;                thisExp.addData(&quot;CurrentMemorySetSize&quot;, curMemSize)&amp;#10;&amp;#10;                thisExp.addData(&quot;TimeBetweenShapes&quot;, timeBetweenShapes)&amp;#10;                thisExp.addData(&quot;ShapeDuration&quot;, startShapeDur)&amp;#10;&amp;#10;                thisExp.addData(&quot;TrialType&quot;, trialType)&amp;#10;&amp;#10;                thisExp.addData(&quot;CurrentScore&quot;, curScore)&amp;#10;                thisExp.addData(&quot;MaxScore_Trial&quot;, maxScoreTrial)&amp;#10;                thisExp.addData(&quot;MaxScore_Total&quot;, totalHighScore)&amp;#10;&amp;#10;                for temp in range(len(selectedShapesNum)):&amp;#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_DraggedTo&quot;, selectedShapesNum[temp])&amp;#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_Score&quot;, allScores[temp])&amp;#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_Placed&quot;, placedShapes[temp])&amp;#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectShape&quot;, allObjects[temp])&amp;#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectPosition&quot;, allPositions[temp])&amp;#10;                    for temp2 in range(len(correctAtt[temp])):&amp;#10;                        thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectColors&quot;, correctAtt[temp][0][temp2])&amp;#10;                        thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectShapes&quot;, correctAtt[temp][1][temp2])&amp;#10;&amp;#10;            curMemTrial += 1&amp;#10;            trialNum += 1&amp;#10;&amp;#10;            startShapeDur -= 0.1&amp;#10;            timeBetweenShapes -= 0.4&amp;#10;&amp;#10;            whenToInc = [6,15]&amp;#10;&amp;#10;            if curMemTrial in  whenToChange:&amp;#10;                timeBetweenShapes = 1.0&amp;#10;                startShapeDur = 0.8&amp;#10;&amp;#10;            if trialNum in whenToInc:&amp;#10;                curMemSize += 1&amp;#10;                startShapeDur=1.0&amp;#10;                curMemTrial = 0&amp;#10;&amp;#10;            ####Inner Loop end&amp;#10;&amp;#10;    doneText = visual.TextStim(window, text=&quot;You are done with the experiment. \&amp;#10;    Press the SPACEBAR to end the task.&quot;,color = (1,-1,-1),pos=(0,0),height=0.03,wrapWidth = instRect.width * 0.95)&amp;#10;&amp;#10;    background.draw()&amp;#10;    scoreRect.draw()&amp;#10;    scoreNum.draw()&amp;#10;    scoreLabel.draw()&amp;#10;    doneText.draw()&amp;#10;    window.flip()&amp;#10;&amp;#10;    event.waitKeys(keyList='space')&amp;#10;&amp;#10;    if WriteData:&amp;#10;        thisExp.addData(&quot;FinalScore&quot;, curScore)&amp;#10;    &amp;#10;    return curScore" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="runTaskAndComments">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="runTaskAndComments" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#myWindow = visual.Window(fullscr = True)&amp;#10;shapeBuilderScore = ShapeBuilderFunction(win=win,physicalMonSize=[33,20.7],writeData = True,computerAndVersionType='macOld',numPracTrials=4)&amp;#10;'''&amp;#10;Optional parameters for ShapeBuilderFunction:&amp;#10;&amp;#10;writeData -- Either True or False. Do you want write data to the data file. Assumed to be True if nothing is given.&amp;#10;&amp;#10;nunPracTrials -- Should be an integer between 0 and 26. It is the number of practice trials participants go through before&amp;#10;               starting the real trials. Set at 6 if nothing is specified. &amp;#10;               &amp;#10;win -- what is the name of the window that you want to use. If not specified, a new window will be created.&amp;#10;&amp;#10;computerAndVersionType -- either 'pc', 'mac', or 'macOld' should be specified. If you have a mac and are using &amp;#10;                          psychopy version 1.82 or earlier, you should specify 'macOld' -- otherwise 'mac'.&amp;#10;&amp;#10;physicalMonSize -- should be a vector with two numbers (e.g., [30,20]). Should correspond to the size of your monitor.&amp;#10;                   width should be listed first. This will alter how the stimuli appear. If this is mis-specified, the &amp;#10;                   stimuli will look funky. &amp;#10;&amp;#10;'''" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="ShapebuilderFunction"/>
  </Flow>
</PsychoPy2experiment>

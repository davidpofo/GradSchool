<PsychoPy2experiment version="1.82.01" encoding="utf-8">
  <Settings>
    <Param name="Show mouse" val="False" valType="bool" updates="None"/>
    <Param name="Data filename" val="'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])" valType="code" updates="None"/>
    <Param name="Monitor" val="testMonitor" valType="str" updates="None"/>
    <Param name="Enable Escape" val="True" valType="bool" updates="None"/>
    <Param name="color" val="$[0,0,0]" valType="str" updates="None"/>
    <Param name="Window size (pixels)" val="[1024, 768]" valType="code" updates="None"/>
    <Param name="Full-screen window" val="True" valType="bool" updates="None"/>
    <Param name="colorSpace" val="rgb" valType="str" updates="None"/>
    <Param name="Experiment info" val="{'participant':'', 'session':'001'}" valType="code" updates="None"/>
    <Param name="Save csv file" val="False" valType="bool" updates="None"/>
    <Param name="Show info dlg" val="True" valType="bool" updates="None"/>
    <Param name="Save wide csv file" val="True" valType="bool" updates="None"/>
    <Param name="Save psydat file" val="True" valType="bool" updates="None"/>
    <Param name="expName" val="Shapebuilder_8_8_2016" valType="str" updates="None"/>
    <Param name="logging level" val="exp" valType="code" updates="None"/>
    <Param name="blendMode" val="avg" valType="str" updates="None"/>
    <Param name="Save excel file" val="False" valType="bool" updates="None"/>
    <Param name="Units" val="use prefs" valType="str" updates="None"/>
    <Param name="Save log file" val="True" valType="bool" updates="None"/>
    <Param name="Screen" val="1" valType="num" updates="None"/>
  </Settings>
  <Routines>
    <Routine name="ShapebuilderFunction">
      <CodeComponent name="function">
        <Param name="Begin Experiment" val="" valType="extendedCode" updates="constant"/>
        <Param name="name" val="function" valType="code" updates="None"/>
        <Param name="Begin Routine" val="#&#10;&#10;def ShapeBuilderFunction(**OptionalParameters):&#10;&#10;    #&#10;    #####################   MODULES TO IMPORT&#10;    #########################################################################################################&#10;    #########################################################################################################&#10;    #########################################################################################################&#10;    #&#10;    import math&#10;    import numpy as np&#10;    import random&#10;    from psychopy import visual, info, core&#10;    from sys import platform as _platform&#10;    import numbers&#10;&#10;#    jeopardy = sound.SoundPyo(volume = 1)&#10;#    jeopardy.setSound('jeopardy.wav')&#10;#    expInfo = info.RunTimeInfo(refreshTest = None)&#10;#    versionNum = int(str(expInfo['psychopyVersion']).replace('.',''))&#10;&#10;    #&#10;    #####################   Functions&#10;    #########################################################################################################&#10;    #########################################################################################################&#10;    #########################################################################################################&#10;    #&#10;    def EucDist(Pos1,Pos2):&#10;        return math.sqrt(abs(Pos1[0]-Pos2[0])**2 + abs(Pos1[1]-Pos2[1])**2)&#10;&#10;    def shift(seq, n):&#10;        n = n % len(seq)&#10;        return seq[n:] + seq[:n]&#10;&#10;    def DrawStimuliFlip(WhatToDisplay,Window):&#10;        [curImage.draw() for curImage in WhatToDisplay]&#10;        Window.flip()&#10;&#10;    def AngleCalc(Rad,Xorigin,Yorigin,YCorrectionFactor,AngleNum,Start):&#10;        X=Start - float(360)/AngleNum&#10;        Degrees = []&#10;        for i in range(0,AngleNum):&#10;            X = X + float(360)/AngleNum&#10;            Degrees.append(X)&#10;        Degrees=np.array(Degrees)&#10;        Xcoordinates=Xorigin + np.cos(np.deg2rad(Degrees)) * Rad&#10;        Ycoordinates=Yorigin + np.sin(np.deg2rad(Degrees)) * Rad * YCorrectionFactor&#10;        return (zip(Xcoordinates,Ycoordinates))&#10;&#10;    #This is just used because I have had problems with the mouse &#10;    #when switching between macs and windows. The main issue is that&#10;    #event.Mouse() has issues if a window (e.g., event.Mouse(win =myWindow) is not supplied on windows machines&#10;    #however, on macs specifying the window causes problems, but only on older versions &#10;    #of psychopy...what a mess. On a mac, with new versions (&gt;1.82..I think!), you need to specify the window.&#10;    #Thus, this function gets what the version.&#10;    def DetermineSystemType(psychopyVersion):&#10;        if _platform == &quot;linux&quot; or _platform == &quot;linux2&quot;:&#10;            core.quit()&#10;        elif _platform == &quot;darwin&quot;:&#10;            if versionNum &lt;= 18201:&#10;                compType = 'mac'&#10;            else:&#10;                compType = 'pc'&#10;        elif _platform == &quot;win32&quot;:&#10;            compType = 'pc'&#10;        else:&#10;            compType = 'pc'&#10;        return(compType)&#10;&#10;&#10;    ################# Optional Paramaeter Stuff&#10;    #########################################################################################################&#10;    #########################################################################################################&#10;    #########################################################################################################&#10;    #Do you want to write data to the file&#10;    if 'writeData' in OptionalParameters:&#10;        WriteData = OptionalParameters['writeData']&#10;        if WriteData not in [True,False]:&#10;            print('Only True or False are possible parameters for writeData brahh!')&#10;    elif 'writeData' not in OptionalParameters:&#10;        WriteData = True&#10;&#10;    if 'numPracTrials' in OptionalParameters:&#10;        if isinstance(OptionalParameters['numPracTrials'],numbers.Number):&#10;            if OptionalParameters['numPracTrials'] &lt; 27 and OptionalParameters['numPracTrials'] &gt; -1:&#10;                numPracticeTrials = int(OptionalParameters['numPracTrials'])&#10;            elif OptionalParameters['numPracTrials'] &lt; 0 or OptionalParameters['numPracTrials'] &gt; 26:&#10;                print('Please enter a non-negative integer for the number of practice trials that is less than 26.')&#10;                core.quit()&#10;        else:&#10;            print('Please enter a single number for &quot;numPracTrials&quot;.')&#10;            core.quit()&#10;    elif 'numPracTrials' not in OptionalParameters:&#10;        numPracticeTrials = 6&#10;&#10;&#10;    if 'win' in OptionalParameters:&#10;        window = OptionalParameters['win']&#10;    elif 'win' not in OptionalParameters:&#10;        window = visual.Window(fullscr=True,monitor='Default',units='norm',colorSpace='rgb')&#10;&#10;    #Had to include this because I was having trouble &#10;    #automatically detecting the version type on windows machines.&#10;    if 'computerAndVersionType' in OptionalParameters:&#10;        if OptionalParameters['computerAndVersionType'] == 'pc':&#10;            myMouse = event.Mouse(win=window)&#10;        elif OptionalParameters['computerAndVersionType'] == 'mac':&#10;            myMouse = event.Mouse(win=window)&#10;        elif OptionalParameters['computerAndVersionType'] == 'macOld':&#10;            myMouse = event.Mouse()&#10;        else:&#10;            print('Not a valid option for &quot;computerAndVersionType&quot; -- &quot;pc&quot;, &quot;mac&quot;, or &quot;macOld&quot; d00d.')&#10;            core.quit()&#10;    elif 'computerAndVersionType' not in OptionalParameters:&#10;        myMouse = event.Mouse(win=window)&#10;&#10;    if 'physicalMonSize' in OptionalParameters:&#10;        screenRez = win.size&#10;        physicalMonSize = OptionalParameters['physicalMonSize']&#10;        yCorrFactor = float(physicalMonSize[0])/physicalMonSize[1]&#10;    elif 'physicalMonSize' not in OptionalParameters:&#10;        yCorrFactor = 1.6&#10;&#10;&#10;    background = visual.Rect(window, size=(window.size)*2, fillColor=(-1.0,-1.0,-1.0))&#10;    #Enter monitor size in cm. If left at [0,0] it is assumed that&#10;    #1 pixel on the x axis is the same size as 1 pixel on the y axis&#10;    monSize=[0,0]&#10;&#10;    shapeLWidth=3&#10;    lineCol=[-1,-1,-1]&#10;&#10;    trialNum = 0 &#10;    curMemSize=2&#10;    startShapeDur=0.7&#10;    curScore = 0&#10;    curMemTrial = 0&#10;    timeBetweenShapes = 0.5&#10;    &#10;    if numPracticeTrials == 0:&#10;        numTimesThroughSB = 1&#10;    else:&#10;        numTimesThroughSB = 2&#10;&#10;    timesThrough = 0&#10;    whenToChange = [3,6,9]&#10;&#10;    difColors=[&#10;    [ 1, 1,-1],&#10;    [-1,-1, 1],&#10;    [ 1,-1,-1],&#10;    [-1, 1,-1]&#10;    ]&#10;&#10;#    edges=[[-0.32,0.32],[0.32,0.32],[0.32,-0.32],[-0.32,-0.32]]&#10;    edges=[[-0.25,0.25],[0.25,0.25],[0.25,-0.25],[-0.25,-0.25]]&#10;    edges=[[curEdge[0],curEdge[1]*yCorrFactor] for curEdge in edges]&#10;&#10;    Ydist=float(max(edges[0][0],edges[2][0]) - min(edges[0][0],edges[2][0]))/5*yCorrFactor&#10;    Xdist=float(max(edges[1][0],edges[3][0]) - min(edges[1][0],edges[3][0]))/5&#10;&#10;    outerRect=visual.Rect(window,lineWidth=0,lineColor=(-0.6,-0.6,-0.6),fillColor=(0,0,0),width=abs(edges[0][0])*5,height=abs(edges[0][0])*4*yCorrFactor,pos=(0,0))&#10;    outerRectShapeColor = visual.Rect(window,lineWidth=0,fillColor=[-0.2,-0.2,-0.2],width=abs(edges[0][0])*5*1.01,height=abs(edges[0][0])*4*yCorrFactor*1.01,pos=outerRect.pos,opacity=0.4)&#10;    defRectColor = outerRectShapeColor.fillColor&#10;&#10;    triangleDistX=0.052&#10;    triangleDistY=triangleDistX * yCorrFactor&#10;&#10;    realTriDistX = triangleDistX * 0.8&#10;    realTriDistY = triangleDistY * 1.45&#10;    triangleYAdj = 2.9&#10;&#10;    if yCorrFactor &gt; 1.3:&#10;        textSizeInc = 0.65&#10;        realTriDistX = triangleDistX * 0.8&#10;        realTriDistY = triangleDistY * 1.45&#10;        triangleYAdj = 2.9&#10;    else:&#10;        textSizeInc = 0.45&#10;        realTriDistX = triangleDistX * 0.8&#10;        realTriDistY = triangleDistY * 1.65&#10;        triangleYAdj = 2.5&#10;&#10;&#10;    pushOut = 1.05&#10;&#10;    allPos = []&#10;    cenPos = []&#10;    for i in range(0,len(edges)):&#10;        curPos=[]&#10;        if i == 0 or i== 2:&#10;            curEdgeDist = float(max(edges[i][0],edges[i+1][0]) - min(edges[i][0],edges[i+1][0]))/5&#10;            float(max(edges[i][0],edges[i+1][0]) - min(edges[i][0],edges[i+1][0]))/2&#10;            if i == 0:&#10;                for j in range(1,5):&#10;                    curPos.append([edges[i][0] + curEdgeDist*j,edges[i][1]])&#10;            else:&#10;                for j in range(1,5):&#10;                    curPos.append([edges[i][0] - curEdgeDist*j,edges[i][1]])&#10;                curPos=curPos[::-1]&#10;        elif i == 1:&#10;            curEdgeDist = float(max(edges[i][1],edges[i+1][1]) - min(edges[i][1],edges[i+1][1]))/5&#10;            for j in range(1,5):&#10;                curPos.append([edges[i][0], edges[i][1] - curEdgeDist*j])&#10;        else:&#10;            curEdgeDist = float(max(edges[3][1],edges[0][1]) - min(edges[3][1],edges[0][1]))/5&#10;            for j in range(1,5):&#10;                curPos.append([edges[i][0], edges[i][1] + curEdgeDist*j])&#10;            curPos=curPos[::-1]&#10;        allPos.append(curPos)&#10;    for i in range(len(allPos)):&#10;        for j in range(len(allPos[i])):&#10;            for k in range(1):&#10;                if i == 0 or i == 2:&#10;                    allPos[i][j][1] = float(allPos[i][j][1]) * pushOut&#10;                else:&#10;                    allPos[i][j][0] = float(allPos[i][j][0]) * pushOut&#10;&#10;&#10;    squareOutlinePos=[]&#10;&#10;    allSquarePos=[]&#10;    allXSqPos=[]&#10;    allYSqPos=[]&#10;    yTempStart = edges[0][0]&#10;    for i in range(1,5):&#10;        allXSqPos.append(edges[0][0]+Xdist*i)&#10;        allYSqPos.append(-edges[0][1]+Ydist*i)&#10;&#10;    for i in range(0,len(allYSqPos)):&#10;        for j in range(0,len(allXSqPos)):&#10;            allSquarePos.append([allXSqPos[j],allYSqPos[i]])&#10;&#10;    allSquareRect=[]&#10;    for i in range(0,len(allSquarePos)):&#10;        allSquareRect.append(visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0.4,0.4,0.4),width=Xdist,height=Ydist,pos=allSquarePos[i]))&#10;&#10;&#10;    scoreRect=visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0.45,0.45,0.45),width=Xdist*2.5,height=Ydist*0.8,pos=(0,edges[0][1]*1.5))&#10;&#10;    scoreNum=visual.TextStim(window, text=curScore,color = (-1,0.2,0.2),pos=scoreRect.pos,height=Ydist*0.7)&#10;    scoreLabel=visual.TextStim(window, text=&quot;Score&quot;,color = 'black',pos=(scoreRect.pos[0],scoreRect.pos[1]+Ydist*0.8),height=Ydist*0.5)&#10;&#10;    scoreValueTexts=[visual.TextStim(window, text=0,color = (-1,-1,-1),pos=scoreRect.pos,height=Ydist*0.6) for i in range(0,4)]&#10;&#10;    beginRect=visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0,0.3,0.8),width=Xdist*2,height=Ydist*0.8,pos=(0.2,edges[0][1]*-1.5))&#10;    beginText=visual.TextStim(window, text=&quot;Begin&quot;,color = (-1,-1,-1),pos=beginRect.pos,height=Ydist*0.5)&#10;&#10;    practiceRect=visual.Rect(window,lineWidth=shapeLWidth*2,lineColor=lineCol,fillColor=(0,0.3,0.8),width=Xdist*2,height=Ydist*0.8,pos=(-beginRect.pos[0],edges[0][1]*-1.5))&#10;    practiceText=visual.TextStim(window, text=&quot;Practice&quot;,color = (-1,-1,-1),pos=practiceRect.pos,height=beginText.height)&#10;&#10;    rectangles=[]&#10;    testRect=[]&#10;    unRect=[]&#10;    for i in range(0,len(edges)):&#10;        curPos=allPos[i][0]&#10;        rectangles.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],width=triangleDistX*1.4,height=triangleDistY*1.4,pos=curPos))&#10;        testRect.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],width=triangleDistX*1.4,height=triangleDistY*1.4,pos=curPos))&#10;        unRect.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],width=triangleDistX*1.4,height=triangleDistY*1.4,pos=curPos))&#10;&#10;    circles=[]&#10;    testCircles=[]&#10;    unCircles=[]&#10;    for i in range(0,len(edges)):&#10;        curPos=allPos[i][1]&#10;        curVertices = AngleCalc(float(triangleDistX)/2*1.5,0,0,yCorrFactor,90,-90)&#10;        circles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&#10;        testCircles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&#10;        unCircles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&#10;&#10;&#10;&#10;&#10;    triangles=[]&#10;    testTriangles=[]&#10;    unTriangles=[]&#10;    for i in range(0,len(edges)):&#10;        curPos=allPos[i][2]&#10;        triangles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i], \&#10;                        vertices=((-realTriDistX,-float(realTriDistX)/2*triangleYAdj),(0,float(realTriDistY)/2),(realTriDistX,-float(realTriDistX)/2*triangleYAdj)), closeShape=True, pos=curPos))&#10;        testTriangles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i], \&#10;                        vertices=((-realTriDistX,-float(realTriDistX)/2*triangleYAdj),(0,float(realTriDistY)/2),(realTriDistX,-float(realTriDistX)/2*triangleYAdj)), closeShape=True, pos=curPos))&#10;        unTriangles.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i], \&#10;                        vertices=((-realTriDistX,-float(realTriDistX)/2*triangleYAdj),(0,float(realTriDistY)/2),(realTriDistX,-float(realTriDistX)/2*triangleYAdj)), closeShape=True, pos=curPos))&#10;&#10;&#10;    diamonds=[]&#10;    testDiamonds=[]&#10;    unDiamonds=[]&#10;    diamondCorrX = 1.15&#10;    diamondCorrY = 1.6&#10;    for i in range(0,len(edges)):&#10;        curPos=allPos[i][3]&#10;        curVertices = [[0,float(triangleDistY)*diamondCorrY/2],[float(triangleDistX)*diamondCorrX/2,0],[0,-(float(triangleDistY)*diamondCorrY/2)],[-(float(triangleDistX)*diamondCorrX/2),0]]&#10;        diamonds.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&#10;        testDiamonds.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&#10;        unDiamonds.append(visual.ShapeStim(window,lineWidth=shapeLWidth,lineColor=lineCol,fillColor=difColors[i],vertices=curVertices,pos=curPos))&#10;&#10;    instRect = visual.Rect(window,lineWidth=shapeLWidth,lineColor='black',fillColor=(0,0,0),width=Xdist*4,height=Ydist*4,pos=(0,0),opacity=0.9)&#10;&#10;    borderingRects = []&#10;    borderingRects2 = []&#10;    for i in range(0,len(edges)):&#10;        if i == 0 or i ==2:&#10;            curPos=[edges[i][0]*pushOut,0]&#10;            curXSize = Xdist&#10;            curYSize = Ydist*4&#10;        else:&#10;            curPos=[0,edges[i][1]*pushOut]&#10;            curXSize = Xdist*4&#10;            curYSize = Ydist&#10;            &#10;        borderingRects.append(visual.Rect(window,lineWidth=0,lineColor='black',fillColor=(0,0,0),width=curXSize,height=curYSize,pos=curPos,opacity=0.6))&#10;        borderingRects2.append(visual.Rect(window,lineWidth=shapeLWidth,lineColor='black',fillColor=(0.4,0.4,0.4),width=curXSize,height=curYSize,pos=curPos))&#10;&#10;&#10;&#10;&#10;    allShapes=[]&#10;    testShapes=[]&#10;    unShapes=[]&#10;    for i in range(0,4):&#10;        allShapes.append(rectangles[i])&#10;        allShapes.append(circles[i])&#10;        allShapes.append(triangles[i])&#10;        allShapes.append(diamonds[i])&#10;        testShapes.append(testRect[i])&#10;        testShapes.append(testCircles[i])&#10;        testShapes.append(testTriangles[i])&#10;        testShapes.append(testDiamonds[i])&#10;        unShapes.append(unRect[i])&#10;        unShapes.append(unCircles[i])&#10;        unShapes.append(unTriangles[i])&#10;        unShapes.append(unDiamonds[i])&#10;&#10;&#10;    allPosFlat=np.array(allPos)&#10;    allPosFlat=np.reshape(allPosFlat,(allPosFlat.shape[0]*allPosFlat.shape[1],allPosFlat.shape[2]))&#10;    allPosFlat=allPosFlat.tolist()&#10;&#10;    allStimNoPres = []&#10;    allStimNoPres.extend([outerRectShapeColor,outerRect,scoreRect,scoreLabel,scoreNum])&#10;    for i in range(len(allSquareRect)):&#10;        allStimNoPres.append(allSquareRect[i])&#10;    [allStimNoPres.append(borderingRects2[i]) for i in range(len(borderingRects2))]&#10;    for i in range(len(allShapes)):&#10;        allStimNoPres.append(allShapes[i])&#10;&#10;&#10;    ####################### Outer loop starts here&#10;    for outerLoop in range(numTimesThroughSB):&#10;&#10;        curScore = 0&#10;&#10;        instructions='This task tests your ability to remember the ' +\&#10;        'order and spatial position in which a series of colored geometric ' +\&#10;        'shapes are presented. You will see between 2 and 4 shapes. Your job ' +\&#10;        'is to remember the order, spatial position, color, and shape of each ' +\&#10;        'item presented. After the final shape is presented, recreate the ' +\&#10;        'sequence by clicking on the correct colored shape and dragging ' +\&#10;        'it to the appropriate spatial position. The better you do the ' +\&#10;        'more points you will earn. The number of points you earn will ' +\&#10;        'increase the more you get correct without making a mistake. ' +\&#10;        'Click begin to start.'&#10;&#10;        instStim = visual.TextStim(window, text=instructions,color = (-1,-1,-1),pos=(0,0),height=triangleDistX*textSizeInc,wrapWidth = instRect.width * 0.93)&#10;        outerRect.setOpacity(0.6)&#10;        &#10;        &#10;#        compType = DetermineSystemType(versionNum)&#10;#        if compType == 'pc':&#10;#            myMouse = event.Mouse(win=window)&#10;#        elif compType == 'mac':&#10;#            myMouse = event.Mouse()&#10;&#10;&#10;        background.draw()&#10;        [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;        outerRect.draw()&#10;        instRect.draw()&#10;        instStim.draw()&#10;        if timesThrough == 0:&#10;            if numPracticeTrials &gt; 0:&#10;                practiceRect.draw()&#10;                practiceText.draw()&#10;            else:&#10;                beginRect.draw()&#10;                beginText.draw()&#10;        else:&#10;            beginRect.draw()&#10;            beginText.draw()&#10;&#10;&#10;        window.flip()&#10;&#10;        somethingPressed = False&#10;        while not somethingPressed:&#10;            for key in event.getKeys():&#10;                if key in ['escape']:&#10;                    core.quit()&#10;            if myMouse.isPressedIn(beginRect) and timesThrough == 0:&#10;                numTimesThroughSB = 1&#10;                trialNums = [26,26]&#10;                trialTypes = [&quot;ExperimentalTrials&quot;,&quot;ExperimentalTrials&quot;]&#10;                somethingPressed = True&#10;            elif myMouse.isPressedIn(practiceRect):&#10;                numTimesThroughSB = 2&#10;                trialNums = [numPracticeTrials,26]&#10;                trialTypes = [&quot;Practice&quot;,&quot;ExperimentalTrials&quot;]&#10;                somethingPressed = True&#10;            elif myMouse.isPressedIn(beginRect) and timesThrough == 1:&#10;                somethingPressed = True&#10;                trialTypes = [&quot;Practice&quot;,&quot;ExperimentalTrials&quot;]&#10;&#10;&#10;        trialNum = 0 &#10;        curMemSize=2&#10;        startShapeDur=0.7&#10;        curMemTrial = 0&#10;        timeBetweenShapes = 0.5&#10;        totalHighScore = 0&#10;&#10;        scoreNum.setText(curScore)&#10;&#10;        timeBetweenShapes = 1.0&#10;        startShapeDur = 0.8&#10;&#10;        &#10;&#10;        trialType = trialTypes[timesThrough]&#10;        numTrials = trialNums[timesThrough]&#10;        outerRect.setOpacity(1.0)&#10;        shiftNums = [0,4,8,12]&#10;        timeShifts = [0.25]*3 + [0.5]&#10;&#10;&#10;#        jeopardy.play()&#10;        for k in range(len(timeShifts)):&#10;            for i in range(len(shiftNums)):&#10;                colorsDummy = shift(allPosFlat,shiftNums[i])&#10;                [allShapes[j].setPos(colorsDummy[j]) for j in range(len(allShapes))]&#10;                background.draw()&#10;                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                window.flip()&#10;                countDown1 = core.CountdownTimer(timeShifts[k])&#10;                while countDown1.getTime() &gt; 0:&#10;                    doNothing = 1&#10;&#10;&#10;        [allShapes[j].setPos(allPosFlat[j]) for j in range(len(allShapes))]&#10;        background.draw()&#10;        [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;        window.flip()&#10;&#10;&#10;        timesThrough += 1&#10;&#10;        #####################################Outer loop ends here&#10;        for shapeBuilderInnerLoop in range(numTrials):&#10;            myMouse.setVisible(False)&#10;&#10;            ranNumStim=[i for i in xrange(0,len(testShapes))]&#10;            random.shuffle(ranNumStim)&#10;&#10;            ranNumPos=[i for i in xrange(0,len(allSquarePos))]&#10;            random.shuffle(ranNumPos)&#10;&#10;            allSameColor=np.array([[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15]])&#10;            allSameShape=np.transpose(allSameColor)&#10;&#10;            allShapeTestPos=[i for i in range(len(allSquarePos))]&#10;            allShapeTestRandom=[i for i in range(len(allSquarePos))]&#10;            random.shuffle(allShapeTestRandom)&#10;&#10;            normList = [i for i in range(len(allSameColor))]&#10;            colorShuffle = [i for i in range(len(allSameColor))]&#10;            shapeShuffle = [i for i in range(len(allSameColor))]&#10;            random.shuffle(colorShuffle)&#10;            random.shuffle(shapeShuffle)&#10;&#10;            whatType = random.randint(0,2)&#10;&#10;            correctShapesList=[]&#10;            correctShapes=[]&#10;            correctAtt=[]&#10;            cTrialShapes=[]&#10;            positions=[]&#10;            AA=0&#10;            BB=0&#10;&#10;            oneStep = [9,10,11,18,19,20,21,22,23]&#10;            allDiff = [3,4,5,12,13,14,24,25]&#10;&#10;            if curMemSize == 4 and trialNum in [18,19,20]:&#10;                changeIt = [0,2]&#10;                random.shuffle(changeIt)&#10;                changeIt = changeIt[0]&#10;            else:&#10;                changeIt = random.randint(0,curMemSize-2)&#10;&#10;            allObjects = []&#10;            allPositions = []&#10;            for i in range(0,curMemSize):&#10;                curColor = normList[colorShuffle[AA]]&#10;                curShape = normList[shapeShuffle[BB]]&#10;                if whatType == 0:&#10;                    if (trialNum in allDiff):&#10;                        AA += 1&#10;                        BB += 1&#10;                    elif (trialNum in oneStep) and (i==changeIt):&#10;                        AA += 1&#10;                        BB += 1&#10;                    else: &#10;                        AA += 0&#10;                        BB += 1&#10;                else:&#10;                    if (trialNum in allDiff):&#10;                        AA += 1&#10;                        BB += 1&#10;                    elif (trialNum in oneStep) and (i==changeIt):&#10;                        AA += 1&#10;                        BB += 1&#10;                    else: &#10;                        AA += 1&#10;                        BB += 0&#10;                curObject = allSameColor[curColor][curShape]&#10;                allObjects.append(curObject)&#10;                newShape=testShapes[curObject]&#10;                newShape.setPos(allSquarePos[allShapeTestPos[allShapeTestRandom[i]]])&#10;                cTrialShapes.append(newShape)&#10;                correctShapes.append([curObject,allShapeTestPos[allShapeTestRandom[i]]])&#10;                allPositions.append(allShapeTestRandom[i])&#10;                correctAtt.append([allSameColor[curColor].tolist(),allSameShape[curShape].tolist()])&#10;&#10;            core.wait(1.0)&#10;            for i in xrange(0,len(cTrialShapes)):&#10;                background.draw()&#10;                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                [borderingRects[j].draw() for j in range(len(borderingRects))]&#10;                window.flip()&#10;                core.wait(timeBetweenShapes)&#10;                background.draw()&#10;                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                [borderingRects[j].draw() for j in range(len(borderingRects))]&#10;                cTrialShapes[i].draw()&#10;                window.flip()&#10;                core.wait(startShapeDur)&#10;&#10;            background.draw()&#10;&#10;            [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;            window.flip()&#10;&#10;&#10;            grabbedShape = -1&#10;#            myMouse.setVisible(visible=True)&#10;&#10;            selectedShapesNum = []&#10;            timer = [core.CountdownTimer(400.0) for i in range(curMemSize)]&#10;            perfect = 0&#10;            limboShapes = []&#10;            limbShapesTime = [0,0,0,0]&#10;            coloredRectsBin = [0,0,0,0]&#10;            allScores=[]&#10;            placedShapes=[]&#10;            coloredRects=[]&#10;            lightSquare = 0&#10;            #Mouse start&#10;            myMouse.setVisible(True)&#10;            while len(selectedShapesNum) &lt; curMemSize: #continue until keypress&#10;                if sum(limbShapesTime) &gt; 0:&#10;                    outerRectShapeColor.fillColor = defRectColor&#10;                    for j in range(len(limboShapes)):&#10;                        if timer[j].getTime() &lt;= 0:&#10;                            limbShapesTime[j] = 0&#10;                    lightSquare = 0&#10;                    background.draw()&#10;                    coloredRects=[]&#10;                    [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&#10;                    [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                    [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                    [allShapes[k].draw() for k in range(len(allShapes))]&#10;                    [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                    window.flip()&#10;                for key in event.getKeys():&#10;                    if key in ['escape']:&#10;                        core.quit()&#10;                for i in range(0,len(allShapes)):&#10;                    if myMouse.isPressedIn(allShapes[i]) == True:&#10;                        grabbedShape = i&#10;                        allShapes[i].setPos(myMouse.getPos())&#10;                        mouse1, mouse2, mouse3 = myMouse.getPressed()&#10;                        clickedOn = True&#10;                        if grabbedShape &lt;= 3 and grabbedShape &gt; -1:&#10;                            curRectCol = 0&#10;                        elif grabbedShape &lt;= 7 and grabbedShape &gt; 3:&#10;                            curRectCol = 1&#10;                        elif grabbedShape &lt;= 11 and grabbedShape &gt; 7:&#10;                            curRectCol = 2&#10;                        elif grabbedShape &lt;= 15 and grabbedShape &gt; 11:&#10;                            curRectCol = 3&#10;                        outerRectShapeColor.fillColor = difColors[curRectCol]&#10;                        while (clickedOn):&#10;                            allShapes[grabbedShape].setPos(myMouse.getPos())&#10;                            for j in range(len(allSquarePos)):&#10;                                if EucDist([allShapes[grabbedShape].pos[0],allShapes[grabbedShape].pos[1]],allSquarePos[allShapeTestPos[allShapeTestRandom[j]]]) &lt;= 0.06:&#10;                                    coloredRects = []&#10;                                    coloredRectsBin[len(selectedShapesNum)] = 1&#10;                                    lightSquare = 1&#10;                                    coloredRects.append(visual.Rect(window,lineWidth=shapeLWidth*3,lineColor=difColors[curRectCol],fillColor=(0.4,0.4,0.4),width=Xdist,height=Ydist,pos=allSquarePos[allShapeTestPos[allShapeTestRandom[j]]],opacity=0.5))&#10;                            background.draw()&#10;                            [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                            if lightSquare == 1:&#10;                                [coloredRects[k].draw() for k in range(len(coloredRects))]&#10;                            [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                            [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                            [allShapes[k].draw() for k in range(len(allShapes))]&#10;                            window.flip()&#10;                            mouse1, mouse2, mouse3 = myMouse.getPressed()&#10;                            if not mouse1:&#10;                                for j in xrange(0,len(allSquarePos)):&#10;                                    if EucDist([allShapes[grabbedShape].pos[0],allShapes[grabbedShape].pos[1]],allSquarePos[allShapeTestPos[allShapeTestRandom[j]]]) &lt;= 0.06:&#10;                                        placedShapes.append(grabbedShape)&#10;                                        squareSel = allShapeTestPos[allShapeTestRandom[j]]&#10;                                        selectedShapesNum.append(squareSel)&#10;                                        if lightSquare == 1:&#10;                                            [coloredRects[k].draw() for k in range(len(coloredRects))]&#10;                                        unShapes[grabbedShape].setPos(allSquarePos[squareSel])&#10;                                        unShapes[grabbedShape].draw()&#10;                                        ShapeSet = True&#10;                                        curShapeVal = 0&#10;                                        if squareSel == correctShapes[len(selectedShapesNum)-1][1]:&#10;                                            if grabbedShape == correctShapes[len(selectedShapesNum)-1][0]:&#10;                                                if len(selectedShapesNum)-1 == 0 or perfect == 0:&#10;                                                    curShapeVal = 15&#10;                                                else:&#10;                                                    curShapeVal = int(scoreValueTexts[len(selectedShapesNum)-2].text) * 2&#10;                                                perfect = 1&#10;                                            elif grabbedShape in correctAtt[len(selectedShapesNum)-1][1]:&#10;                                                curShapeVal = 10&#10;                                                perfect = 0&#10;                                            elif squareSel == correctShapes[len(selectedShapesNum)-1][1]:&#10;                                                curShapeVal = 5&#10;                                                perfect = 0&#10;                                            else :&#10;                                                curShapeVal = 0&#10;                                                perfect = 0&#10;                                        curScore += curShapeVal&#10;#                                        scoreNum.setText(curScore)&#10;                                        allScores.append(curShapeVal)&#10;                                        [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&#10;                                        scoreValueTexts[len(selectedShapesNum)-1].setText(curShapeVal)&#10;                                        scoreValueTexts[len(selectedShapesNum)-1].setPos(allSquarePos[squareSel])&#10;                                        timer[len(selectedShapesNum)-1] = core.CountdownTimer(1.5)&#10;                                        unShapes[grabbedShape].setPos(allSquarePos[squareSel])&#10;                                        limboShapes.append(unShapes[grabbedShape])&#10;                                        limbShapesTime[len(selectedShapesNum)-1] = 1&#10;                                        clickedOn = False&#10;                                background.draw()&#10;                                [allStimNoPres[k].draw() for k in range(len(allStimNoPres))]&#10;                                if lightSquare == 1:&#10;                                    [coloredRects[k].draw() for k in range(len(coloredRects))]&#10;                                [limboShapes[k].draw() for  k in range(len(limboShapes)) if limbShapesTime[k] == 1]&#10;                                [scoreValueTexts[k].draw() for  k in range(len(limboShapes)) if limbShapesTime[k] == 1]&#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&#10;                                clickedOn = False&#10;                            if sum(limbShapesTime) &gt; 0:&#10;                                for j in range(len(limboShapes)):&#10;                                    if timer[j].getTime() &lt;= 0:&#10;                                        limbShapesTime[j] = 0&#10;                                background.draw()&#10;                                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                                if lightSquare == 1:&#10;                                    [coloredRects[k].draw() for k in range(len(coloredRects))]&#10;                                [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                                [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&#10;                                window.flip()&#10;                        if clickedOn == False:&#10;                            outerRectShapeColor.fillColor = defRectColor&#10;                            lightSquare = 0&#10;                            if sum(limbShapesTime) &gt; 0:&#10;                                for j in range(len(limboShapes)):&#10;                                    if timer[j].getTime() &lt;= 0:&#10;                                        limbShapesTime[j] = 0&#10;                                lightSquare = 0&#10;                                background.draw()&#10;                                coloredRects=[]&#10;                                [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&#10;                                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                                [limboShapes[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                                [scoreValueTexts[j].draw() for  j in range(len(limboShapes)) if limbShapesTime[j] == 1]&#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&#10;                                window.flip()&#10;                            else:&#10;                                background.draw()&#10;                                [allShapes[k].setPos(allPosFlat[k]) for k in range(len(allShapes))]&#10;                                [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;                                [allShapes[k].draw() for k in range(len(allShapes))]&#10;                                window.flip()&#10;                event.clearEvents()#get rid of other, unprocessed events&#10;&#10;            countDown3 = core.CountdownTimer(0.5)&#10;            while countDown3.getTime() &gt; 0:&#10;                doNothing = 1&#10;&#10;            if (curScore - int(scoreNum.text)) &lt;= 0:&#10;                scoreTime = 0.1&#10;            else:&#10;                scoreTime = (0.75/(curScore - int(scoreNum.text)))*0.25&#10;            countDown1 = core.CountdownTimer(1.5)&#10;            countDown2 = core.CountdownTimer(0)&#10;            if curScore - int(scoreNum.text) &lt; 45:&#10;                curInc = 1&#10;            elif curScore - int(scoreNum.text) &lt; 100:&#10;                curInc = 5&#10;            else:&#10;                curInc = 10&#10;            while countDown1.getTime() &gt; 0:&#10;                countDown2.add(scoreTime)&#10;                if (curScore - int(scoreNum.text)) &lt; 11:&#10;                    curInc = 1&#10;                if int(scoreNum.text) &lt; curScore:&#10;                    scoreNum.setText(int(scoreNum.text) + curInc)&#10;                else:&#10;                    scoreNum.setText(curScore)&#10;                DrawStimuliFlip([background] + allShapes + allStimNoPres + allShapes,window)&#10;                while countDown2.getTime() &gt; 0:&#10;                    doNothing = 1&#10;            scoreNum.setText(curScore)&#10;&#10;            background.draw()&#10;            [allShapes[i].setPos(allPosFlat[i]) for i in range(len(allShapes))]&#10;            [allStimNoPres[j].draw() for j in range(len(allStimNoPres))]&#10;&#10;            window.flip()&#10;&#10;&#10;            posHighSchores = [15,30,60,120]&#10;            maxScoreTrial = sum(posHighSchores[0:curMemSize])&#10;            totalHighScore += maxScoreTrial&#10;            &#10;            if WriteData:&#10;                thisExp.addData(&quot;Trial&quot;, trialNum)&#10;                thisExp.addData(&quot;CurrentMemorySetSize&quot;, curMemSize)&#10;&#10;                thisExp.addData(&quot;TimeBetweenShapes&quot;, timeBetweenShapes)&#10;                thisExp.addData(&quot;ShapeDuration&quot;, startShapeDur)&#10;&#10;                thisExp.addData(&quot;TrialType&quot;, trialType)&#10;&#10;                thisExp.addData(&quot;CurrentScore&quot;, curScore)&#10;                thisExp.addData(&quot;MaxScore_Trial&quot;, maxScoreTrial)&#10;                thisExp.addData(&quot;MaxScore_Total&quot;, totalHighScore)&#10;&#10;                for temp in range(len(selectedShapesNum)):&#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_DraggedTo&quot;, selectedShapesNum[temp])&#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_Score&quot;, allScores[temp])&#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_Placed&quot;, placedShapes[temp])&#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectShape&quot;, allObjects[temp])&#10;                    thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectPosition&quot;, allPositions[temp])&#10;                    for temp2 in range(len(correctAtt[temp])):&#10;                        thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectColors&quot;, correctAtt[temp][0][temp2])&#10;                        thisExp.addData(&quot;Shape_&quot; + str(temp+1) + &quot;_CorrectShapes&quot;, correctAtt[temp][1][temp2])&#10;&#10;            curMemTrial += 1&#10;            trialNum += 1&#10;&#10;            startShapeDur -= 0.1&#10;            timeBetweenShapes -= 0.4&#10;&#10;            whenToInc = [6,15]&#10;&#10;            if curMemTrial in  whenToChange:&#10;                timeBetweenShapes = 1.0&#10;                startShapeDur = 0.8&#10;&#10;            if trialNum in whenToInc:&#10;                curMemSize += 1&#10;                startShapeDur=1.0&#10;                curMemTrial = 0&#10;&#10;            ####Inner Loop end&#10;&#10;    doneText = visual.TextStim(window, text=&quot;You are done with the experiment. \&#10;    Press the SPACEBAR to end the task.&quot;,color = (1,-1,-1),pos=(0,0),height=0.03,wrapWidth = instRect.width * 0.95)&#10;&#10;    background.draw()&#10;    scoreRect.draw()&#10;    scoreNum.draw()&#10;    scoreLabel.draw()&#10;    doneText.draw()&#10;    window.flip()&#10;&#10;    event.waitKeys(keyList='space')&#10;&#10;    if WriteData:&#10;        thisExp.addData(&quot;FinalScore&quot;, curScore)&#10;    &#10;    return curScore" valType="extendedCode" updates="constant"/>
        <Param name="End Routine" val="" valType="extendedCode" updates="constant"/>
        <Param name="End Experiment" val="" valType="extendedCode" updates="constant"/>
        <Param name="Each Frame" val="" valType="extendedCode" updates="constant"/>
      </CodeComponent>
      <CodeComponent name="runTaskAndComments">
        <Param name="Begin Experiment" val="" valType="extendedCode" updates="constant"/>
        <Param name="name" val="runTaskAndComments" valType="code" updates="None"/>
        <Param name="Begin Routine" val="#&#10;myWindow = visual.Window(fullscr = True)&#10;shapeBuilderScore = ShapeBuilderFunction(win=myWindow,physicalMonSize=[33,20.7],writeData = True,computerAndVersionType='macOld',numPracTrials=4)&#10;'''&#10;Optional parameters for ShapeBuilderFunction:&#10;&#10;writeData -- Either True or False. Do you want write data to the data file. Assumed to be True if nothing is given.&#10;&#10;nunPracTrials -- Should be an integer between 0 and 26. It is the number of practice trials participants go through before&#10;               starting the real trials. Set at 6 if nothing is specified. &#10;               &#10;win -- what is the name of the window that you want to use. If not specified, a new window will be created.&#10;&#10;computerAndVersionType -- either 'pc', 'mac', or 'macOld' should be specified. If you have a mac and are using &#10;                          psychopy version 1.82 or earlier, you should specify 'macOld' -- otherwise 'mac'.&#10;&#10;physicalMonSize -- should be a vector with two numbers (e.g., [30,20]). Should correspond to the size of your monitor.&#10;                   width should be listed first. This will alter how the stimuli appear. If this is mis-specified, the &#10;                   stimuli will look funky. &#10;&#10;'''" valType="extendedCode" updates="constant"/>
        <Param name="End Routine" val="" valType="extendedCode" updates="constant"/>
        <Param name="End Experiment" val="" valType="extendedCode" updates="constant"/>
        <Param name="Each Frame" val="" valType="extendedCode" updates="constant"/>
      </CodeComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="ShapebuilderFunction"/>
  </Flow>
</PsychoPy2experiment>
